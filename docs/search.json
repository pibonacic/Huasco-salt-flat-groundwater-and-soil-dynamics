[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Exploración de las relaciones entre aguas subterráneas y variables edáficas",
    "section": "",
    "text": "Los humedales altoandinos son piezas clave de los balances de agua, energía y carbono en la región del Altiplano, procesos que dependen de la disponibilidad de aguas subterráneas cercanas a la superficie.\nPese a su relevancia, estos ecosistemas enfrentan amenazas crecientes debido al cambio climático y la actividad minera. Además, los métodos de monitoreo hidrogeológico actuales son caros y difíciles de implementar en estos ambientes remotos.\nPor tanto, el objetivo de este trabajo es explorar las relaciones entre profundidad del agua subterránea y variables medidas en el suelo para evaluar el desarrollo de metodologías de monitoreo alternativas, usando el Salar del Huasco como caso de estudio.\n\n\n\nLocalización del Salar del Huasco y sus estaciones de monitoreo\n\n\nEn la actualidad, se cuenta con dos estaciones de monitoreo en el sitio: norte y sur. En este trabajo se emplearán los datos recolectados en la estación norte, donde se cuenta con un piezómetro y tres sensores de suelo ubicados a diferentes profundidades (15, 30 y 48 cm). El piezómetro reporta la profundidad del nivel freático (m), mientras que los sensores de suelo, datos de contenido de agua (m³/m³)y temperatura (°C)."
  },
  {
    "objectID": "index.html#introduccióncontexto",
    "href": "index.html#introduccióncontexto",
    "title": "Estructura de proyecto final",
    "section": "",
    "text": "Dos alternativas (no excluyentes): - Establecimiento de la relevancia de la investigación - Contextualización del área de estudio y de los sensores usados\n\n\n\nLocalización del área de estudio"
  },
  {
    "objectID": "index.html#resultadosanálisis-exploratorio",
    "href": "index.html#resultadosanálisis-exploratorio",
    "title": "Estructura de proyecto final",
    "section": "Resultados/análisis exploratorio",
    "text": "Resultados/análisis exploratorio\nIntercalar secuencias de texto introductorio y explicativo con gráficas clave.\n\nPreprocesamiento\nLectura y formateo de datos\n\n\nCode\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n\n# Cargar Datos\npiezo_df = pd.read_csv(\n    '../data/processed/03_daily/piezo-data_SDH1PS01_daily.csv', \n    parse_dates=['Timestamps'], index_col='Timestamps',\n    usecols=['Timestamps', 'depth_m']\n)\n\nsoil_df = pd.read_csv(\n    '../data/processed/03_daily/soil-data_z6-25818_daily.csv', \n    parse_dates=['Timestamps'], index_col='Timestamps',\n    usecols=['Timestamps',\n             'TEROS12_15cm_water-content_m3/m3', 'TEROS12_30cm_water-content_m3/m3', 'TEROS12_48cm_water-content_m3/m3',\n             'TEROS12_15cm_soil-temperature_degree_C', 'TEROS12_30cm_soil-temperature_degree_C', 'TEROS12_48cm_soil-temperature_degree_C']\n)\n\n# Diccionarios de mapeo para nombres más limpios y extracción de metadatos\n# Formato: Sensor_Profundidad_Variable\nsoil_rename_map = {\n    'TEROS12_15cm_water-content_m3/m3': 'Suelo_15cm_Contenido-agua',\n    'TEROS12_30cm_water-content_m3/m3': 'Suelo_30cm_Contenido-agua',\n    'TEROS12_48cm_water-content_m3/m3': 'Suelo_48cm_Contenido-agua',\n    'TEROS12_15cm_soil-temperature_degree_C': 'Suelo_15cm_Temperatura',\n    'TEROS12_30cm_soil-temperature_degree_C': 'Suelo_30cm_Temperatura',\n    'TEROS12_48cm_soil-temperature_degree_C': 'Suelo_48cm_Temperatura'\n}\n\n# Renombrar columnas\nsoil_df = soil_df.rename(columns=soil_rename_map)\npiezo_df = piezo_df.rename(columns={'depth_m': 'Piezometro_NA_Profundidad-nivel-freatico'})\n\n# Unir datasets\ndf_merged = pd.merge(piezo_df, soil_df, left_index=True, right_index=True, how='inner')\n\n# Transformar a formato largo\ndf_long = df_merged.reset_index().melt(id_vars='Timestamps', var_name='metadata', value_name='Valor')\n\n# Extraer metadatos dividiendo el string por guiones bajos (estructura: Sensor_Profundidad_Variable)\nmetadata_split = df_long['metadata'].str.split('_', expand=True)\ndf_long['Sensor'] = metadata_split[0]           # Ej: Suelo, Piezometro\ndf_long['Profundidad'] = metadata_split[1]  # Ej: 15cm, 30cm, NA\ndf_long['Variable'] = metadata_split[2]         # Ej: Contenido-agua, Temperatura\n\n# Generacion de un espacio entre el numero y la unidad para etiquetas\ndf_long['Profundidad_label'] = df_long['Profundidad'].str.replace('cm', ' cm').replace('NA', 'NA')\n\n# Definir etiquetas limpias para los gráficos\nvariable_labels = {\n    'Profundidad-nivel-freatico': 'Prof. del nivel freático (m)',\n    'Contenido-agua': 'Contenido de agua (m³/m³)',\n    'Temperatura': 'Temperatura (°C)'\n}\n# Mapeamos para usar en el facet grid\ndf_long['Variable_label'] = df_long['Variable'].map(variable_labels)\n\n# Orden específico para las profundidades en la leyenda\nsoil_depth_order = ['15 cm', '30 cm', '48 cm']\nfull_depth_order = ['15 cm', '30 cm', '48 cm', 'NA']\n\n\n\n\nVisualización preliminar\n\n\nCode\n# Configuración de estilo\nsns.set_theme(style=\"ticks\", context=\"notebook\", font_scale=1)\nplt.rcParams['axes.grid'] = True\nplt.rcParams['grid.alpha'] = 0.3\nplt.rcParams['figure.figsize'] = (12, 8)\n\n# Configuracion de paleta de colores\nviridis_colors = sns.color_palette(\"viridis_r\", n_colors=3)\npalette_dict = {\n    '15 cm': viridis_colors[0], # Más claro (verde claro)\n    '30 cm': viridis_colors[1], # Medio (verde azulado)\n    '48 cm': viridis_colors[2], # Más oscuro (morado)\n    'NA': 'black'               # Negro\n}\n\n# Generar la figura base usando relplot\ng = sns.relplot(\n    data=df_long,\n    x='Timestamps',\n    y='Valor',\n    row='Variable_label',      # Crea una fila por cada variable\n    hue='Profundidad_label',   # Diferencia colores según profundidad\n    kind='line',\n    palette=palette_dict,      # Uso de diccionario de colores personalizado\n    hue_order=full_depth_order,\n    height=3,\n    aspect=3.5,\n    facet_kws={'sharey': False, 'sharex': True} # Eje X compartido, Eje Y independiente\n)\n\n# Personalización de ejes y paneles\ng.set_titles(\"\")  # Eliminar los títulos sobre cada panel\ng.set_xlabels(\"\") # Eliminar la etiqueta del eje X\n\n# Iterar sobre cada panel (subplot) para aplicar estilos específicos\nfor i, (ax, title) in enumerate(zip(g.axes.flat, g.row_names)):\n    # Etiqueta del eje Y: Texto normal y alineado\n    ax.set_ylabel(title, fontweight='normal')\n    \n    # Configuración específica para el primer panel (Nivel Freático)\n    if 'Prof. del nivel freático (m)' in title:\n        ax.invert_yaxis() # Invertir eje\n        \n        # Dibujar líneas de referencia horizontales para la ubicación de sensores\n        sensor_depths_m = [0.15, 0.30, 0.48]\n        sensor_labels = ['15 cm', '30 cm', '48 cm']\n        \n        for d_m, lbl in zip(sensor_depths_m, sensor_labels):\n            # Línea punteada del color correspondiente al sensor\n            ax.axhline(y=d_m, color=palette_dict[lbl], linestyle='--', linewidth=1, alpha=0.8)\n\n    # Formato de fecha en el eje X\n    date_fmt = mdates.DateFormatter('%d %b %Y')\n    ax.xaxis.set_major_formatter(date_fmt)\n\n\n# Personalización de la leyenda\n# Extraer los objetos (handles) y etiquetas actuales del primer gráfico\nhandles, labels = g.axes[0,0].get_legend_handles_labels()\n\n# Filtrar la lista para excluir 'NA' (Nivel freático), ya que es la línea negra\nclean_handles = [h for h, l in zip(handles, labels) if l != 'NA']\nclean_labels = [l for l in labels if l != 'NA']\n\n# Eliminar la leyenda por defecto a la derecha\ng._legend.remove()\n\n# Crear una nueva leyenda personalizada\ng.fig.legend(\n    clean_handles, \n    clean_labels, \n    loc='lower center', \n    bbox_to_anchor=(0.5, 0),\n    ncol=3, # Disposición horizontal\n    title=\"Profundidad de los sensores de suelo\",\n    frameon=False\n)\n\n# Ajustes finales\n# Título principal de la figura\ng.fig.suptitle(\"Evolución de variables piezométricas y edáficas\", x=0.5, y=0.98, fontsize=14)\n# Ajustes de espaciado\nplt.tight_layout()\nplt.subplots_adjust(top=0.93, bottom=0.11) # Ajusta espacio disponible para subplots\n\nplt.show()\n\n\n\n\n\nSeries temporales\n\n\n\n\n\n\nCode\n# Preparación de datos para scatter plot\n# Filtrar los datos de suelo\ndf_soil = df_long[df_long['Sensor'] == 'Suelo'].copy()\n\n# Extraer la serie de nivel freático (NA) y convertir en una columna\npiezo_col = df_long[df_long['Profundidad_label'] == 'NA'].set_index('Timestamps')['Valor']\n\n# Unir por fecha\ndf_scatter = df_soil.merge(piezo_col.rename('GWD'), left_on='Timestamps', right_index=True)\n\n# Generar la figura base usando relplot scatter\ng2 = sns.relplot(\n    data=df_scatter,\n    x='Valor',                  # Eje X: Variables de suelo\n    y='GWD',                    # Eje Y: Nivel freático\n    row='Profundidad_label',    # Filas: Profundidad (15, 30, 48)\n    col='Variable_label',       # Columnas: Variable (Contenido-agua, Temperatura)\n    hue='Profundidad_label',\n    kind='scatter',\n    palette=palette_dict,\n    row_order=soil_depth_order, # 15, 30, 48\n    hue_order=soil_depth_order,\n    height=3,\n    aspect=1.2,\n    facet_kws={'sharey': True, 'sharex': 'col'}, \n    alpha=0.7,\n    s=30\n)\n\n# Personalización de ejes y paneles\n# Eliminar los títulos automáticos de los subplots\ng2.set_titles(\"\") \n\n# Inversión del eje Y\n# Calcular min y max de los datos para establecer los límites manualmente\ny_min = df_scatter['GWD'].min()\ny_max = df_scatter['GWD'].max()\npadding = (y_max - y_min) * 0.05 # Agregar un 5% de espacio\ng2.set(ylim=(y_max + padding, y_min - padding))\n\n# Configurar etiquetas del eje X en la fila inferior\ng2.set_xlabels(\"\") # Limpiar etiquetas automáticas\ng2.axes[-1, 0].set_xlabel(\"Contenido de agua (m³/m³)\")\ng2.axes[-1, 1].set_xlabel(\"Temperatura (°C)\")\n\n# Etiqueta Global del Eje Y\ng2.set_ylabels(\"\") # Borrar etiquetas individuales automáticas\ng2.fig.supylabel(\n    \"Profundidad del nivel freático (m)\", \n    x=0.04, \n    size=plt.rcParams['axes.labelsize'], # Igualar tamaño al eje X\n)\n\n# Personalización de la leyenda\n# Extraer handles/labels del primer panel\nhandles, labels = g2.axes[0,0].get_legend_handles_labels()\n\n# Eliminar la leyenda automática\ng2._legend.remove()\n\n# Crear leyenda personalizada\ng2.fig.legend(\n    handles=handles,\n    labels=labels,\n    loc='lower center',\n    bbox_to_anchor=(0.5, 0), \n    ncol=3,\n    title=\"Profundidad de los sensores de suelo\",\n    frameon=False\n)\n\n# Ajustes finales\n# Título principal\ng2.fig.suptitle(\"Relación entre variables de suelo y profundidad del nivel freático\", y=0.98, fontsize=14)\n\n# Ajustes de espaciado\nplt.tight_layout()\nplt.subplots_adjust(top=0.94, bottom=0.13, left=0.11) # Ajusta espacio disponible para subplots\n\nplt.show()\n\n\n\n\n\nScatter plots\n\n\n\n\n\n\nCorrelaciones cruzadas\n\nTabla con resultados de tests para evaluar estacionariedad de los datos (ADF, KPSS) antes y después del detrending.\nGráficas de series temporales sin tendencia: similar a gráfica 1.\nGráficas de coeficientes de correlación anuales: dos facet (uno por variable: contenido de agua y temperatura), cada uno de tres filas (una por profundidad). Los gráficos comparten el eje X (número de lags).\nGráficas de coeficientes de correlación para una temporada específica (dependiente de la visualización preliminar)."
  },
  {
    "objectID": "index.html#conclusionesdesafíos",
    "href": "index.html#conclusionesdesafíos",
    "title": "Estructura de proyecto final",
    "section": "Conclusiones/desafíos",
    "text": "Conclusiones/desafíos\nDesarrollar una conclusión a partir de los resultados iniciales y cuáles serían próximos pasos a desarrollar para continuar con la investigación:\n\nExploración de correlaciones en diferentes momentos temporales\nExploración de correlaciones con datos de otros sitios\nExploración de correlaciones con otro tipo de datos (meteorológicos, flujos de calor)"
  },
  {
    "objectID": "index.html#contexto",
    "href": "index.html#contexto",
    "title": "Exploración de las relaciones entre aguas subterráneas y variables edáficas",
    "section": "",
    "text": "Los humedales altoandinos son piezas clave de los balances de agua, energía y carbono en la región del Altiplano, procesos que dependen de la disponibilidad de aguas subterráneas cercanas a la superficie.\nPese a su relevancia, estos ecosistemas enfrentan amenazas crecientes debido al cambio climático y la actividad minera. Además, los métodos de monitoreo hidrogeológico actuales son caros y difíciles de implementar en estos ambientes remotos.\nPor tanto, el objetivo de este trabajo es explorar las relaciones entre profundidad del agua subterránea y variables medidas en el suelo para evaluar el desarrollo de metodologías de monitoreo alternativas, usando el Salar del Huasco como caso de estudio.\n\n\n\nLocalización del Salar del Huasco y sus estaciones de monitoreo\n\n\nEn la actualidad, se cuenta con dos estaciones de monitoreo en el sitio: norte y sur. En este trabajo se emplearán los datos recolectados en la estación norte, donde se cuenta con un piezómetro y tres sensores de suelo ubicados a diferentes profundidades (15, 30 y 48 cm). El piezómetro reporta la profundidad del nivel freático (m), mientras que los sensores de suelo, datos de contenido de agua (m³/m³)y temperatura (°C)."
  },
  {
    "objectID": "index.html#análisis-exploratorio",
    "href": "index.html#análisis-exploratorio",
    "title": "Exploración de las relaciones entre aguas subterráneas y variables edáficas",
    "section": "Análisis exploratorio",
    "text": "Análisis exploratorio\nLos datos obtenidos desde los piezómetros y sensores de suelo fueron formateados, se le removieron datos anómalos y se agregaron diariamente. Los scripts correspondientes están disponibles aquí. Los datos crudos y procesados están disponibles aquí.\nEn la siguiente celda de código se realiza el procesamiento previo a la visualización, consistente en la lectura y formateo de los datos diarios.\n\n\nCode\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\n\n# Cargar Datos\npiezo_df = pd.read_csv(\n    '../data/processed/03_daily/piezo-data_SDH1PS01_daily.csv', \n    parse_dates=['Timestamps'], index_col='Timestamps',\n    usecols=['Timestamps', 'depth_m']\n)\n\nsoil_df = pd.read_csv(\n    '../data/processed/03_daily/soil-data_z6-25818_daily.csv', \n    parse_dates=['Timestamps'], index_col='Timestamps',\n    usecols=['Timestamps',\n             'TEROS12_15cm_water-content_m3/m3', 'TEROS12_30cm_water-content_m3/m3', 'TEROS12_48cm_water-content_m3/m3',\n             'TEROS12_15cm_soil-temperature_degree_C', 'TEROS12_30cm_soil-temperature_degree_C', 'TEROS12_48cm_soil-temperature_degree_C']\n)\n\n# Diccionarios de mapeo para nombres más limpios y extracción de metadatos\n# Formato: Sensor_Profundidad_Variable\nsoil_rename_map = {\n    'TEROS12_15cm_water-content_m3/m3': 'Suelo_15cm_Contenido-agua',\n    'TEROS12_30cm_water-content_m3/m3': 'Suelo_30cm_Contenido-agua',\n    'TEROS12_48cm_water-content_m3/m3': 'Suelo_48cm_Contenido-agua',\n    'TEROS12_15cm_soil-temperature_degree_C': 'Suelo_15cm_Temperatura',\n    'TEROS12_30cm_soil-temperature_degree_C': 'Suelo_30cm_Temperatura',\n    'TEROS12_48cm_soil-temperature_degree_C': 'Suelo_48cm_Temperatura'\n}\n\n# Renombrar columnas\nsoil_df = soil_df.rename(columns=soil_rename_map)\npiezo_df = piezo_df.rename(columns={'depth_m': 'Piezometro_NA_Profundidad-nivel-freatico'})\n\n# Unir datasets\ndf_merged = pd.merge(piezo_df, soil_df, left_index=True, right_index=True, how='inner')\n\n# Transformar a formato largo\ndf_long = df_merged.reset_index().melt(id_vars='Timestamps', var_name='metadata', value_name='Valor')\n\n# Extraer metadatos dividiendo el string por guiones bajos (estructura: Sensor_Profundidad_Variable)\nmetadata_split = df_long['metadata'].str.split('_', expand=True)\ndf_long['Sensor'] = metadata_split[0]           # Ej: Suelo, Piezometro\ndf_long['Profundidad'] = metadata_split[1]  # Ej: 15cm, 30cm, NA\ndf_long['Variable'] = metadata_split[2]         # Ej: Contenido-agua, Temperatura\n\n# Generacion de un espacio entre el numero y la unidad para etiquetas\ndf_long['Profundidad_label'] = df_long['Profundidad'].str.replace('cm', ' cm').replace('NA', 'NA')\n\n# Definir etiquetas limpias para los gráficos\nvariable_labels = {\n    'Profundidad-nivel-freatico': 'Prof. del nivel freático (m)',\n    'Contenido-agua': 'Contenido de agua (m³/m³)',\n    'Temperatura': 'Temperatura (°C)'\n}\n# Mapeamos para usar en el facet grid\ndf_long['Variable_label'] = df_long['Variable'].map(variable_labels)\n\n# Orden específico para las profundidades en la leyenda\nsoil_depth_order = ['15 cm', '30 cm', '48 cm']\nfull_depth_order = ['15 cm', '30 cm', '48 cm', 'NA']\n\n\nEn primer lugar, se graficaron las series de tiempo de profundidad del nivel freático, así como de contenido de agua y temperatura del suelo a las tres profundidades disponibles.\n\n\nCode\n# Configuración de estilo\nsns.set_theme(style=\"ticks\", context=\"notebook\", font_scale=1)\nplt.rcParams['axes.grid'] = True\nplt.rcParams['grid.alpha'] = 0.3\nplt.rcParams['figure.figsize'] = (12, 8)\n\n# Configuracion de paleta de colores\nviridis_colors = sns.color_palette(\"viridis_r\", n_colors=3)\npalette_dict = {\n    '15 cm': viridis_colors[0], # Más claro (verde claro)\n    '30 cm': viridis_colors[1], # Medio (verde azulado)\n    '48 cm': viridis_colors[2], # Más oscuro (morado)\n    'NA': 'black'               # Negro\n}\n\n# Generar la figura base usando relplot\ng = sns.relplot(\n    data=df_long,\n    x='Timestamps',\n    y='Valor',\n    row='Variable_label',      # Crea una fila por cada variable\n    hue='Profundidad_label',   # Diferencia colores según profundidad\n    kind='line',\n    palette=palette_dict,      # Uso de diccionario de colores personalizado\n    hue_order=full_depth_order,\n    height=3,\n    aspect=3.5,\n    facet_kws={'sharey': False, 'sharex': True} # Eje X compartido, Eje Y independiente\n)\n\n# Personalización de ejes y paneles\ng.set_titles(\"\")  # Eliminar los títulos sobre cada panel\ng.set_xlabels(\"\") # Eliminar la etiqueta del eje X\n\n# Iterar sobre cada panel (subplot) para aplicar estilos específicos\nfor i, (ax, title) in enumerate(zip(g.axes.flat, g.row_names)):\n    # Etiqueta del eje Y: Texto normal y alineado\n    ax.set_ylabel(title, fontweight='normal')\n    \n    # Configuración específica para el primer panel (Nivel Freático)\n    if 'Prof. del nivel freático (m)' in title:\n        ax.invert_yaxis() # Invertir eje\n        \n        # Dibujar líneas de referencia horizontales para la ubicación de sensores\n        sensor_depths_m = [0.15, 0.30, 0.48]\n        sensor_labels = ['15 cm', '30 cm', '48 cm']\n        \n        for d_m, lbl in zip(sensor_depths_m, sensor_labels):\n            # Línea punteada del color correspondiente al sensor\n            ax.axhline(y=d_m, color=palette_dict[lbl], linestyle='--', linewidth=1, alpha=0.8)\n\n    # Formato de fecha en el eje X\n    date_fmt = mdates.DateFormatter('%d %b %Y')\n    ax.xaxis.set_major_formatter(date_fmt)\n\n\n# Personalización de la leyenda\n# Extraer los objetos (handles) y etiquetas actuales del primer gráfico\nhandles, labels = g.axes[0,0].get_legend_handles_labels()\n\n# Filtrar la lista para excluir 'NA' (Nivel freático), ya que es la línea negra\nclean_handles = [h for h, l in zip(handles, labels) if l != 'NA']\nclean_labels = [l for l in labels if l != 'NA']\n\n# Eliminar la leyenda por defecto a la derecha\ng._legend.remove()\n\n# Crear una nueva leyenda personalizada\ng.fig.legend(\n    clean_handles, \n    clean_labels, \n    loc='lower center', \n    bbox_to_anchor=(0.5, 0),\n    ncol=3, # Disposición horizontal\n    title=\"Profundidad de los sensores de suelo\",\n    frameon=False\n)\n\n# Ajustes finales\n# Ajustes de espaciado\nplt.tight_layout()\nplt.subplots_adjust(top=0.93, bottom=0.11) # Ajusta espacio disponible para subplots\n\nplt.show()\n\n\n\n\n\nSeries temporales de profundidad del nivel freático, contenido de agua y temperatura del suelo\n\n\n\n\nLuego, se graficó la relación entre profundidad del nivel freático y las variables de suelo mediante gráficos de dispersión.\n\n\nCode\n# Preparación de datos para scatter plot\n# Filtrar los datos de suelo\ndf_soil = df_long[df_long['Sensor'] == 'Suelo'].copy()\n\n# Extraer la serie de nivel freático (NA) y convertir en una columna\npiezo_col = df_long[df_long['Profundidad_label'] == 'NA'].set_index('Timestamps')['Valor']\n\n# Unir por fecha\ndf_scatter = df_soil.merge(piezo_col.rename('GWD'), left_on='Timestamps', right_index=True)\n\n# Generar la figura base usando relplot scatter\ng2 = sns.relplot(\n    data=df_scatter,\n    x='Valor',                  # Eje X: Variables de suelo\n    y='GWD',                    # Eje Y: Nivel freático\n    row='Profundidad_label',    # Filas: Profundidad (15, 30, 48)\n    col='Variable_label',       # Columnas: Variable (Contenido-agua, Temperatura)\n    hue='Profundidad_label',\n    kind='scatter',\n    palette=palette_dict,\n    row_order=soil_depth_order, # 15, 30, 48\n    hue_order=soil_depth_order,\n    height=3,\n    aspect=1.2,\n    facet_kws={'sharey': True, 'sharex': 'col'}, \n    alpha=0.7,\n    s=30\n)\n\n# Personalización de ejes y paneles\n# Eliminar los títulos automáticos de los subplots\ng2.set_titles(\"\") \n\n# Inversión del eje Y\n# Calcular min y max de los datos para establecer los límites manualmente\ny_min = df_scatter['GWD'].min()\ny_max = df_scatter['GWD'].max()\npadding = (y_max - y_min) * 0.05 # Agregar un 5% de espacio\ng2.set(ylim=(y_max + padding, y_min - padding))\n\n# Configurar etiquetas del eje X en la fila inferior\ng2.set_xlabels(\"\") # Limpiar etiquetas automáticas\ng2.axes[-1, 0].set_xlabel(\"Contenido de agua (m³/m³)\")\ng2.axes[-1, 1].set_xlabel(\"Temperatura (°C)\")\n\n# Etiqueta Global del Eje Y\ng2.set_ylabels(\"\") # Borrar etiquetas individuales automáticas\ng2.fig.supylabel(\n    \"Profundidad del nivel freático (m)\", \n    x=0.04, \n    size=plt.rcParams['axes.labelsize'], # Igualar tamaño al eje X\n)\n\n# Personalización de la leyenda\n# Extraer handles/labels del primer panel\nhandles, labels = g2.axes[0,0].get_legend_handles_labels()\n\n# Eliminar la leyenda automática\ng2._legend.remove()\n\n# Crear leyenda personalizada\ng2.fig.legend(\n    handles=handles,\n    labels=labels,\n    loc='lower center',\n    bbox_to_anchor=(0.5, 0), \n    ncol=3,\n    title=\"Profundidad de los sensores de suelo\",\n    frameon=False\n)\n\n# Ajustes finales\n# Ajustes de espaciado\nplt.tight_layout()\nplt.subplots_adjust(top=0.94, bottom=0.13, left=0.11) # Ajusta espacio disponible para subplots\n\nplt.show()\n\n\n\n\n\nRelaciones entre profundidad del nivel freático y variables edáficas\n\n\n\n\n\nTabla con resultados de tests para evaluar estacionariedad de los datos (ADF, KPSS) antes y después del detrending.\nGráficas de series temporales sin tendencia: similar a gráfica 1.\nGráficas de coeficientes de correlación anuales: dos facet (uno por variable: contenido de agua y temperatura), cada uno de tres filas (una por profundidad). Los gráficos comparten el eje X (número de lags).\nGráficas de coeficientes de correlación para una temporada específica (dependiente de la visualización preliminar)."
  },
  {
    "objectID": "index.html#desafíos",
    "href": "index.html#desafíos",
    "title": "Exploración de las relaciones entre aguas subterráneas y variables edáficas",
    "section": "Desafíos",
    "text": "Desafíos\nDesarrollar una conclusión a partir de los resultados iniciales y cuáles serían próximos pasos a desarrollar para continuar con la investigación:\n\nExploración de correlaciones en diferentes momentos temporales\nExploración de correlaciones con datos de otros sitios\nExploración de correlaciones con otro tipo de datos (meteorológicos, flujos de calor)"
  }
]